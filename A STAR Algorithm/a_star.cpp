#include<iostream>
#include<vector>
#include<cassert>
#include<map>
#include<algorithm>
using namespace std;

const int INFINITY = INT_MAX;


class Puzzle{
    /*
    Represents a single state of the game i.e. a node in the state-space graph
    Each state is characterized by the
        i. arrangement of elements (numbers from 1 to 8) 
        ii. position of the * depicted by a '0' in elements    
    */
public:
    vector<vector<int>> board;
    pair<int, int> pos;
    int nDims;

    Puzzle(vector<vector<int>> &elements){
        assert(elements.size() == elements[0].size() && "Puzzle must have equal rows and columns");

        this -> board = elements;
        this -> nDims = elements.size();

        for(int i=0;i<nDims;i++){
            for(int j=0;j<nDims;j++){
                if(board[i][j] == 0){
                    pos = make_pair(i, j);
                    break;
                }
            }
        }
    }

    void display(){
        for(int i=0;i<nDims;i++){
            for(int j=0;j<nDims;j++){
                cout<<board[i][j]<<" ";
            }

            cout<<endl;
        }
    }
};


vector<Puzzle> move(Puzzle &puzzle){
    /*
    Given a puzzle (node in the state-space graph), perform all possible actions
    and return the set of states generated by all of those actions
    */

   int x = puzzle.pos.first;
   int y = puzzle.pos.second;
   int dim = puzzle.nDims;
   vector<pair<int, int>> possiblePos;

   if(x+1 < dim && y < dim) possiblePos.push_back(make_pair(x+1, y));
   if(x < dim && y+1 < dim) possiblePos.push_back(make_pair(x, y+1));
   if(x >= 1 && y >= 0) possiblePos.push_back(make_pair(x-1, y));
   if(x >= 0 && y >= 1) possiblePos.push_back(make_pair(x, y-1));

   vector<Puzzle> newStates;
   for(auto p : possiblePos){
    int px = p.first;
    int py = p.second;
    auto newElements = puzzle.board;
    swap(newElements[px][py], newElements[x][y]);
    newStates.push_back(Puzzle(newElements));
   }

   return newStates;
}


int heuristic(Puzzle &initPuzzle, Puzzle &goalPuzzle){
    /*
    A simple heuristic function which counts the number of misplaced elements
    by comparing `initPuzzle` with `goalPuzzle`
    */

   assert(initPuzzle.nDims == goalPuzzle.nDims &&"Puzzles must have equal dimensions");
   int count = 0;

   for(int i=0;i<initPuzzle.nDims;i++){
    for(int j=0;j<initPuzzle.nDims;j++){
        if(initPuzzle.board[i][j] != goalPuzzle.board[i][j]) count++;
    }
   }

   return count;
}


bool isGoal(Puzzle &currPuzzle, Puzzle &goalPuzzle){
    /*
    Goal-test function which checks if all elements are aligned
    */

   assert(currPuzzle.nDims == goalPuzzle.nDims &&"Puzzles must have equal dimensions");

   for(int i=0;i<currPuzzle.nDims;i++){
    for(int j=0;j<currPuzzle.nDims;j++){
        if(currPuzzle.board[i][j] != goalPuzzle.board[i][j]) return false;
    }
   }

   return true;
}



int main() {
    vector<vector<int>> init_elements = {{1, 2, 3}, {0, 4, 6}, {7, 5, 8}};
    Puzzle initPuzzle(init_elements);
    cout << "Initial state:" << endl;
    initPuzzle.display();

    vector<vector<int>> goal_elements = {{1, 2, 3}, {4, 5, 6}, {7, 8, 0}};
    Puzzle goalPuzzle(goal_elements);
    cout << "Goal state:" << endl;
    goalPuzzle.display();

    vector<Puzzle> openSet = {initPuzzle};
    map<Puzzle, int> gScore;
    gScore[initPuzzle] = 0;
    map<Puzzle, int> fScore;
    fScore[initPuzzle] = heuristic(initPuzzle, goalPuzzle);

    cout << "Steps: " << endl;
    while (!openSet.empty()) {
        Puzzle current = openSet[0];
        int minFScore = fScore.find(current) != fScore.end() ? fScore[current] : INFINITY;
        
        for (auto node : openSet) {
            int score = fScore.find(node) != fScore.end() ? fScore[node] : INFINITY;
            if (score < minFScore) {
                minFScore = score;
                current = node;
            }
        }

        current.display();

        if (isGoal(current, goalPuzzle)) {
            cout << "Done" << endl;
            break;
        }

        openSet.erase(remove(openSet.begin(), openSet.end(), current), openSet.end());
        for (auto neighbor : move(current)) {
            int tentgScore = gScore.find(current) != gScore.end() ? gScore[current] + 1 : INFINITY;
            if (tentgScore < gScore[neighbor]) {
                gScore[neighbor] = tentgScore;
                fScore[neighbor] = tentgScore + heuristic(neighbor, goalPuzzle);
                if (find(openSet.begin(), openSet.end(), neighbor) == openSet.end()) {
                    openSet.push_back(neighbor);
                }
            }
        }
    }

    return 0;
}